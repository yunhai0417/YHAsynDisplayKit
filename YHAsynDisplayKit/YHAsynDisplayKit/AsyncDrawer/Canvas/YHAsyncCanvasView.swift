//
//  YHAsyncCanvasView.swift
//  YHAsynDisplayKit
//
//  Created by 吴云海 on 2020/4/1.
//  Copyright © 2020 YH. All rights reserved.
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//  http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//

import UIKit

struct YHAsyncCanvasViewKey {
    static let CornerRadiusKey = "canvas-cornerradius-key"
    static let BorderWidthKey  = "canvas-borderwidth-key"
    static let BorderColorKey  = "canvas-bordercolor-key"
    static let ShadowColorKey  = "canvas-shadowcolor-key"
    static let ShadowOffsetKey = "canvas-shadowoffset-key"
    static let ShadowBlurKey   = "canvas-shadowblur-key"
    static let BackgroundColorKey = "canvas-backgroundcolor-key"
    static let BackgroundImageKey = "canvas-backgroundimage-key"
}

open class YHAsyncCanvasView: YHAsyncDawnView {

    /* When positive, the background of the layer will be drawn with
     * rounded corners. Also effects the mask generated by the
     * `masksToBounds' property. Defaults to zero. Animatable. */
    public var cornerRadius:CGFloat = 0.0
    
    /* The width of the layer's border, inset from the layer bounds. The
     * border is composited above the layer's content and sublayers and
     * includes the effects of the `cornerRadius' property. Defaults to
     * zero. Animatable. */
    public var borderWidth:CGFloat = 0.0
    
    /* The color of the layer's border. Defaults to opaque black. Colors
     * created from tiled patterns are supported. Animatable. */

    public var borderColor:UIColor?
    
    /** Shadow properties. **/
    /* The color of the shadow. Defaults to opaque black. Colors created
     * from patterns are currently NOT supported. Animatable. */
    
    public var shadowColor:UIColor?
    
    /* The shadow offset. Defaults to (0, -3). Animatable. */
    public var shadowOffset: UIOffset = UIOffset.zero
    
    public var shadowBlur:CGFloat = 0.0
    
    fileprivate var _backgroundImage:UIImage?
    public var backgroundImage:UIImage? {
        get {
            return self._backgroundImage
        }
        set {
            if self._backgroundImage != newValue {
                self._backgroundImage = newValue
                self.setContentsChangedAfterLastAsyncDrawing(true)
                self.setNeedsDisplay()
            }
        }
    }
    
    fileprivate var fillColor:UIColor?
    public override var backgroundColor: UIColor? {
        set {
            if self.fillColor != newValue {
                self.fillColor = newValue
                self.setContentsChangedAfterLastAsyncDrawing(true)
                self.setNeedsDisplay()
            }
        }
        get {
            return fillColor
        }
    }
    
    override init(frame: CGRect) {
        super.init(frame: frame)
        self.setDrawingPolicy(.asynchronouslyDrawWhenContentsChanged)
        self.backgroundColor = UIColor.clear
        self.clearsContextBeforeDrawing = false
        self.contentMode = .redraw
    }
    
    required public init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    //
    func setNewBackgroundColor(_ fro:UIColor) {
        if fro != self.fillColor {
            self.fillColor = fro
            self.setContentsChangedAfterLastAsyncDrawing(true)
            self.setNeedsDisplay()
        }
    }
    
    func getBackgroundColor() -> UIColor? {
        return self.fillColor
    }
    
    public override func currentDrawingUserInfo() -> [String:Any] {
        
        var userInfo = [String:Any]()
        
        let dic = super.currentDrawingUserInfo()
        userInfo.merge(dic) { (current, _) in current }
        
        if self.borderWidth > 0.0 {
            userInfo[YHAsyncCanvasViewKey.BorderWidthKey] = self.borderWidth
        }
        
        if self.cornerRadius >= 0.0 {
            userInfo[YHAsyncCanvasViewKey.CornerRadiusKey] = self.cornerRadius
        }
        
        if let borderColor = self.borderColor {
            userInfo[YHAsyncCanvasViewKey.BorderColorKey] = borderColor
        }
        
        if let shadowColor = self.shadowColor {
            userInfo[YHAsyncCanvasViewKey.ShadowColorKey] = shadowColor
        }
        
        if self.shadowOffset != UIOffset.zero {
            userInfo[YHAsyncCanvasViewKey.ShadowOffsetKey] = self.shadowOffset
        }
        
        if self.shadowBlur > 0.0 {
            userInfo[YHAsyncCanvasViewKey.ShadowBlurKey] = self.shadowBlur
        }
        
        if let fillColor = self.fillColor {
            userInfo[YHAsyncCanvasViewKey.BackgroundColorKey] = fillColor
        }
        
        if let backgroundImage = self.backgroundImage {
            userInfo[YHAsyncCanvasViewKey.BackgroundImageKey] = backgroundImage
        }
        
        return userInfo
    }
    
    open override func drawInRect(_ rect: CGRect, context: CGContext?, asynchronously: Bool, userInfo: [String : Any]?) -> Bool {
        _ = super.drawInRect(rect, context: context, asynchronously: asynchronously, userInfo: userInfo)
        
        
        let cornerRadius = (userInfo?[YHAsyncCanvasViewKey.CornerRadiusKey] as? CGFloat) ?? CGFloat.zero
        
        let backgroundColor = userInfo?[YHAsyncCanvasViewKey.BackgroundColorKey] as? UIColor
        
        var borderWidth = userInfo?[YHAsyncCanvasViewKey.BorderWidthKey] as? CGFloat
        if let borderWidth1 = borderWidth {
            borderWidth = borderWidth1 * UIScreen.main.scale
        }
        
        let borderColor = userInfo?[YHAsyncCanvasViewKey.BorderColorKey] as? UIColor
        
        if cornerRadius == 0 {
            if let backgroundColor = backgroundColor, backgroundColor != UIColor.clear {
                context?.setFillColor(backgroundColor.cgColor)
                context?.fill(rect)
            }
            
            if let borderWidth = borderWidth , borderWidth > 0 {
                context?.addPath(UIBezierPath.init(rect: rect).cgPath)
            }
            
            context?.setFillColor(UIColor.clear.cgColor)
            
            if let borderWidth = borderWidth , borderWidth > 0 {
                if let borderColor = borderColor {
                    context?.setStrokeColor(borderColor.cgColor)
                }
                context?.setLineWidth(borderWidth)
                context?.drawPath(using: CGPathDrawingMode.fillStroke)
            }
            
            if let borderWidth = borderWidth , borderWidth <= 0 {
                context?.drawPath(using: CGPathDrawingMode.fill)
            }
            
            
        } else {
            let targetRect = CGRect(x: 0, y: 0, width: rect.size.width, height: rect.size.height)
            let path = UIBezierPath.init(roundedRect: targetRect,
                                         byRoundingCorners: UIRectCorner.allCorners,
                                         cornerRadii: CGSize.init(width: cornerRadius, height: cornerRadius))
            path.usesEvenOddFillRule = true
            path.addClip()
            context?.addPath(path.cgPath)
            
//            var image1 = UIGraphicsGetImageFromCurrentImageContext()

            
            if let backgroundColor = backgroundColor, backgroundColor != UIColor.clear {
                context?.setFillColor(backgroundColor.cgColor)
                context?.fill(rect)
                context?.addPath(path.cgPath)
            }
            
            context?.setFillColor(UIColor.yellow.cgColor)
            
//            var image2 = UIGraphicsGetImageFromCurrentImageContext()

            
            if let borderWidth = borderWidth , borderWidth > 0 {
                if let borderColor = borderColor {
                    context?.setStrokeColor(borderColor.cgColor)
                }
                context?.setLineWidth(borderWidth)
                context?.drawPath(using: CGPathDrawingMode.fillStroke)
            }
            
//            var image3 = UIGraphicsGetImageFromCurrentImageContext()

            
            if let borderWidth = borderWidth , borderWidth <= 0 {
                context?.drawPath(using: CGPathDrawingMode.fill)
            }
            
//            var image4 = UIGraphicsGetImageFromCurrentImageContext()

        }
        
        
        // 阴影设置
        let shadowColor = userInfo?[YHAsyncCanvasViewKey.ShadowColorKey] as? UIColor
        let shadowBlur = userInfo?[YHAsyncCanvasViewKey.ShadowBlurKey] as? CGFloat    ?? 0.0
        let shadowOffset = userInfo?[YHAsyncCanvasViewKey.ShadowOffsetKey] as? UIOffset ?? UIOffset.zero
        
        if let shadowColor = shadowColor {
            context?.setShadow(offset: CGSize.init(width: shadowOffset.horizontal, height: shadowOffset.vertical), blur: shadowBlur, color: shadowColor.cgColor)
        }
        
        if let context = context {
            UIGraphicsPushContext(context)
            let image = userInfo?[YHAsyncCanvasViewKey.BackgroundImageKey] as? UIImage
            image?.draw(in: rect)
            UIGraphicsPopContext()
        }
        
        return true
    }
}
